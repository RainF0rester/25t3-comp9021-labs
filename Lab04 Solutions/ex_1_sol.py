def f1_1(n: int) -> None:
    """
    Prints a sequence for each number from n down to 1.
    
    For each number i, prints the sequence: i, i//2, i//4, ..., 1
    Each integer is printed in a field of width equal to the number of digits in n plus 1.
    
    Uses direct iteration and printing in a loop for concise implementation.
    
    :param n: A positive integer representing the starting number
    """
    # Calculate field width: digits in n plus 1 space
    w = len(str(n)) + 1
    
    # Iterate from n down to 1
    for i in range(n, 0, -1):
        # Store original i to use in the loop since i will be modified
        current = i
        
        # Continue dividing by 2 and printing until we reach 0
        while current:
            # Print the current number with the calculated field width
            # Use str.rjust(width)
            print(str(current).rjust(w), end= "")
            # Or you can use f-string format
            # print(f'{current:{w}}', end='')
            # Integer division by 2 to get the next number in sequence
            current //= 2
            
        # After printing all numbers in the sequence, move to next line
        print()


def f1_2(n: int) -> None:
    """
    Prints a sequence for each number from n down to 1.
    
    For each number i, prints the sequence: i, i//2, i//4, ..., 1
    Each integer is printed in a field of width equal to the number of digits in n plus 1.
    
    Uses list comprehension and join for string formatting.

    :param n: A positive integer representing the starting number
    """
    # Calculate field width: digits in n plus 1 space
    width = len(str(n)) + 1
    
    # Process each number from n down to 1
    for i in range(n, 0, -1):
        # Generate sequence by repeatedly dividing by 2
        num = i
        sequence = []
        while num:
            sequence.append(num)  # Add current number to sequence
            num //= 2             # Divide by 2 to get next number
        
        # Format each number in the sequence with proper width
        formatted_sequence = [f'{num:{width}}' for num in sequence]
        
        # Join all formatted numbers into a single string and print
        print(''.join(formatted_sequence))

def f1_extra(n: int) -> None:
    """
    Prints a transposed (column-based) version of the pattern from f1().
    Each column represents a sequence of integers generated by repeatedly
    dividing the column index (from 1 to n) by 2 (integer division)
    until the value becomes smaller than 1. The pattern is then transposed
    so that we print the data **by row**, showing the pattern growing
    from top to bottom instead of left to right.
    Example:
        # >>> f1(n)
            '''
             13  6  3  1\n
             12  6  3  1\n
             11  5  2  1\n
             10  5  2  1\n
              9  4  2  1\n
              8  4  2  1\n
              7  3  1\n
              6  3  1\n
              5  2  1\n
              4  2  1\n
              3  1\n
              2  1\n
              1\n
            '''
        >>> f1_extra(13)
        13 12 11 10  9  8  7  6  5  4  3  2  1
         6  6  5  5  4  4  3  3  2  2  1  1
         3  3  2  2  2  2  1  1  1  1
         1  1  1  1  1  1

    :param n: A positive integer representing the starting number
    :return:
    """

    from itertools import zip_longest

    # We'll use this width to right-align numbers for clean formatting.
    w = len(str(n))
    cols = []
    # Step 1: Build all columns.
    # Each column corresponds to one integer from n down to 1.
    # These will later become the *vertical* columns of our pattern.
    for i in range(n, 0, -1):
        # Generate seq by repeatedly dividing by 2
        num = i
        seq = [] # create a new list for this column
        while num:
            seq.append(num)  # Add current number to seq
            num //= 2             # Divide by 2 to get next number
        cols.append(seq) # append the column to cols

    # Step 2: Transpose the data so that columns become rows.
    # zip_longest() combines the i-th element of each column into a row.
    # If a column is shorter than others, it fills missing entries
    # with the specified fillvalue (an empty string here).
    for row in zip_longest(*cols, fillvalue=""):
        result = []
        # Step 3: Format each element in the row.
        # - If the element is a number, right-align it within width w.
        for digit in row:
            result.append(str(digit).rjust(w))
        # Step 4: Join all elements in the row with a single space,
        # and remove trailing spaces for clean right edges.
        print(" ".join(result).rstrip())